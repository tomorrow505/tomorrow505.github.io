<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Github+Hexo绑定到Godaddy域名</title>
    <link href="/2021/ckmgbiu2e0000dsag6mnaf7y7/"/>
    <url>/2021/ckmgbiu2e0000dsag6mnaf7y7/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>本着不折腾浑身难受的理念，按照教程<strong>绑定GitHub上的个人博客到Godaddy域名</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="绑定Github上的个人博客到Godaddy域名">[1]</span></a></sup>做了一次域名解析，发现难倒是不难，就是访问速度变慢了很多。后边再想想要不要CDN加速吧，反正现在先用着。哈哈~将流程记录下来。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><hr><h3 id="1-首先在Godaddy官网购买域名"><a href="#1-首先在Godaddy官网购买域名" class="headerlink" title="1. 首先在Godaddy官网购买域名"></a>1. 首先在<a href="https://sg.godaddy.com/zh/">Godaddy官网</a>购买域名</h3><h3 id="2-配置GitHub"><a href="#2-配置GitHub" class="headerlink" title="2. 配置GitHub"></a>2. 配置GitHub</h3><p>在Hexo的source目录下创建CNAME文件将域名写进去。之后部署项目。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo ghexo d</code></pre></div><blockquote><p>如果你是用 hexo 框架搭建博客并部署到 Github Pages 上: 每次hexo g hexo d 后会把你的博客所在目录下 public 文件夹里的东西都推到 Github Pages 仓库上，并且把 CNAME 文件覆盖掉，解决这个问题可以直接<strong>把CNAME文件添加到source文件夹里</strong>，这样每次推的时候就不用担心仓库里的 CNAME 文件被覆盖掉了。</p></blockquote><p>折腾的时候放在主目录提交一次删一次。。坑~~</p><blockquote><p><em>还有一种方式是：在网站的Github项目上，点击设置Settings，找到Custom domain，填入申请的域名，并保存。这样也会在Github项目的根目录看到这个文件，但是当你在每次部署项目之后，这个CNAME文件都会消失，本质上相当于你新建的CNAME放在了本地Github项目的根目录了，而不是在source文件夹下。</em></p></blockquote><h3 id="3-向你的-DNS-配置中添加-3-条记录（在域名解析提供商，下面以dnspod为例）"><a href="#3-向你的-DNS-配置中添加-3-条记录（在域名解析提供商，下面以dnspod为例）" class="headerlink" title="3. 向你的 DNS 配置中添加 3 条记录（在域名解析提供商，下面以dnspod为例）"></a>3. 向你的 DNS 配置中添加 3 条记录（在<a href="https://cloud.tencent.com/product/cns?from=10680">域名解析</a>提供商，下面以dnspod为例）</h3><table><thead><tr><th>Host(主机记录)</th><th>记录类型</th><th>Points To(记录值)</th></tr></thead><tbody><tr><td>@</td><td>A</td><td>192.30.252.153</td></tr><tr><td>@</td><td>A</td><td>192.30.252.154</td></tr><tr><td>www</td><td>CNAME</td><td>username.github.io</td></tr></tbody></table><h3 id="4-去-GoDaddy-修改-DNS-地址"><a href="#4-去-GoDaddy-修改-DNS-地址" class="headerlink" title="4. 去 GoDaddy 修改 DNS 地址"></a>4. 去 GoDaddy 修改 DNS 地址</h3><p>具体过程去看源帖吧。在更改域名服务器的时候我用的是DNSPod提供的，一开始不会生效，等一会儿就好了。最后就能打开了。</p><h3 id="5-优化参考性及可行性"><a href="#5-优化参考性及可行性" class="headerlink" title="5. 优化参考性及可行性"></a>5. 优化参考性及可行性</h3><p>在帖子<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="优化 Hexo 博客的访问速度">[2]</span></a></sup>发现博客部署在GitHub Pages上，从国内打开访问速度很慢，我第一感觉就是图片加载很慢了。</p><blockquote><p>过慢的访问速度会使得用户在访问网站的时候失去耐心，导致有些用户可能会直接关闭你的网站</p></blockquote><p>我十分认同这样的理念，但是CDN一开始我就没考虑，因为博客刚刚起步，本来就没有什么访客，所以我着眼于图片压缩。</p><ul><li><p>一是压缩图片的尺寸。</p></li><li><p>二是压缩图片的分辨率。</p></li></ul><h3 id="6-不怂就是干，用python来实现一波。"><a href="#6-不怂就是干，用python来实现一波。" class="headerlink" title="6. 不怂就是干，用python来实现一波。"></a>6. 不怂就是干，用python来实现一波。</h3><p>因为这种脚本网上肯定多得很，直接参考了一下这个帖子<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="Python 图片尺寸缩放的4种方式">[3]</span></a></sup>写了一下。</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<span class="hljs-keyword">import</span> shutil<span class="hljs-keyword">import</span> os<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graphics</span>:</span><span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resize_by_height</span>(<span class="hljs-params">cls, height</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;按照高度进行所需比例缩放&quot;&quot;&quot;</span>        im = Image.<span class="hljs-built_in">open</span>(infile)        (x, y) = im.size        x_s = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">float</span>(x)/<span class="hljs-built_in">float</span>(y) * height)        y_s = height        out = im.resize((x_s, y_s), Image.ANTIALIAS)        out.save(outfile, quality=<span class="hljs-number">0.7</span>)        print(<span class="hljs-string">&quot;完成&quot;</span>)<span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resize_by_size</span>(<span class="hljs-params">cls, size</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;按照生成图片文件大小进行处理(单位KB)&quot;&quot;&quot;</span>        size *= <span class="hljs-number">1024</span>        im = Image.<span class="hljs-built_in">open</span>(infile)        size_tmp = os.path.getsize(infile)        q = <span class="hljs-number">100</span>        <span class="hljs-keyword">while</span> size_tmp &gt; size <span class="hljs-keyword">and</span> q &gt; <span class="hljs-number">0</span>:            print(q)            out = im.resize(im.size, Image.ANTIALIAS)            out.save(outfile, quality=q)            size_tmp = os.path.getsize(outfile)            q -= <span class="hljs-number">5</span>        <span class="hljs-keyword">if</span> q == <span class="hljs-number">100</span>:            shutil.copy(infile, outfile)        print(<span class="hljs-string">&quot;完成&quot;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        infile = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你的图片路径: &gt;&gt;&quot;</span>)        <span class="hljs-keyword">if</span> infile == <span class="hljs-string">&quot;exit&quot;</span>:            <span class="hljs-keyword">break</span>        dir_path = os.path.dirname(infile)        base_name = os.path.basename(infile)        tmp_path = os.path.join(dir_path, <span class="hljs-string">&#x27;tmp&#x27;</span>)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.isdir(tmp_path):            os.mkdir(tmp_path)        outfile = os.path.join(tmp_path, base_name)        mode = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你要进行的模式(1、按高160等比缩小到指定尺寸；2、压缩图片size到300KB)&quot;</span>)        <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(mode) == <span class="hljs-number">1</span>:            Graphics.resize_by_height(<span class="hljs-number">160</span>)        <span class="hljs-keyword">else</span>:            Graphics.resize_by_size(<span class="hljs-number">300</span>)</code></pre></div><p>测试了一波，还没有人家提到的站点做的一半好，承让了，直接使用<a href="https://tinypng.com/">TinyPNG</a>来压缩图片。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>其实很多人已经在你前边走了一条路，但是你不走过去，你怎么知道沿途的风景呢？</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://cloud.tencent.com/developer/article/1367881">绑定Github上的个人博客到Godaddy域名</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://kaitohh.com/tweak-hexo/">优化 Hexo 博客的访问速度</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/ln152315/article/details/42777149">Python 图片尺寸缩放的4种方式</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>折腾笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fluid</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-Fluid实现mac panel风格代码块</title>
    <link href="/2021/ckmfpryfc0000u0ag5e79dw4i/"/>
    <url>/2021/ckmfpryfc0000u0ag5e79dw4i/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>一直以来看别人博客都觉的Mac风格的代码块很炫酷，这几天尝试自己搭建博客，选中了<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a>这个主题，但是仅限于支持设定的两种风格。</p><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># 实现高亮的库，对应下面的设置</span><span class="hljs-comment"># Options: highlightjs | prismjs</span><span class="hljs-attr">lib:</span> <span class="hljs-string">&quot;highlightjs&quot;</span><span class="hljs-attr">highlightjs:</span><span class="hljs-comment"># 在链接中挑选 style 填入</span><span class="hljs-comment"># See: https://highlightjs.org/static/demo/</span><span class="hljs-attr">style:</span> <span class="hljs-string">&quot;Monokai Sublime&quot;</span><span class="hljs-comment"># 是否根据 style 改变代码背景色（如果 style 是深色背景别忘了开启此项）</span><span class="hljs-attr">bg_color:</span> <span class="hljs-literal">true</span><span class="hljs-attr">prismjs:</span><span class="hljs-comment"># 在下方链接页面右侧的圆形按钮挑选 style 填入，也可以直接填入 css 链接</span><span class="hljs-comment"># See: https://prismjs.com/</span><span class="hljs-attr">style:</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-comment"># 设为 true 高亮将本地静态生成（并只支持部分 prismjs 插件），设为 false 高亮将在浏览器通过 js 生成</span><span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span></code></pre></div><p>这就让人很为难了，因为也看过一些教程，大多是next怎么做的。找了半天发现了相关为Yilia主题代码块添加Mac Panel效果的一篇教程。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="私人订制 为Yilia主题代码块添加Mac Panel效果">[1]</span></a></sup>所以就跟着弄了一下，也踩了一些坑，花了半天时间终于搞定了。哈哈~记录一下。</p><h3 id="需要的条件"><a href="#需要的条件" class="headerlink" title="需要的条件"></a>需要的条件</h3><hr><p>需要有一点点的css和JavaScript基础以及找寻代码判断相关性的能力。</p><h3 id="大致思想及流程"><a href="#大致思想及流程" class="headerlink" title="大致思想及流程"></a>大致思想及流程</h3><hr><ol><li>自动更改样式。首先得大致知道hexo是如何把markdown的代码渲染出来的，在这个过程之后又怎样匹配出来了自己在ymal中定义的样式呢？</li></ol><p>根据highlightjs和prismjs作为关键字，通过一番查找找到了/fluid/scripts/events/lib/highlights.js，该js函数调用了hexo的生命周期在恰当的时间点博客中代码块内容进行替换，从而使得原有的代码块样式能够被替换指定的风格块。</p><ol start="2"><li>找到了之后如何做呢？首先需要分析代码做了哪些工作。</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (config.code.highlight.lib === <span class="hljs-string">&#x27;highlightjs&#x27;</span>) &#123;    hexo.config.prismjs = objUtil.merge(&#123;&#125;, hexo.config.prismjs, &#123;        enable: <span class="hljs-literal">false</span>    &#125;);    hexo.config.highlight = objUtil.merge(&#123;&#125;, hexo.config.highlight, &#123;        enable     : <span class="hljs-literal">true</span>,        hljs       : <span class="hljs-literal">true</span>,        wrap       : <span class="hljs-literal">false</span>,        auto_detect: <span class="hljs-literal">true</span>,        line_number: config.code.highlight.line_number || <span class="hljs-literal">false</span>    &#125;);    hexo.extend.filter.register(<span class="hljs-string">&#x27;after_post_render&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">page</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (config.code.highlight.highlightjs.bg_color) &#123;            page.content = page.content.replace(<span class="hljs-regexp">/(?&lt;!&lt;div class=&quot;hljs code-wrapper&quot;&gt;)(&lt;pre.+?&lt;\/pre&gt;)/gim</span>s, <span class="hljs-function">(<span class="hljs-params">str, p1</span>) =&gt;</span> &#123;                <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/&lt;code[^&gt;]+?mermaid[^&gt;]+?&gt;/im</span>s.test(p1)) &#123;                    <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/(class=&quot;.*?)hljs(.*?&quot;)/gim</span>s, <span class="hljs-string">&#x27;$1$2&#x27;</span>);                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;div class=&quot;hljs code-wrapper&quot;&gt;<span class="hljs-subst">$&#123;p1&#125;</span>&lt;/div&gt;`</span>;            &#125;);            page.content = page.content.replace(<span class="hljs-regexp">/&lt;td class=&quot;gutter/gim</span>s, <span class="hljs-string">&#x27;&lt;td class=&quot;gutter hljs&#x27;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!hexo.config.highlight.line_number) &#123;            page.content = page.content.replace(<span class="hljs-regexp">/(?&lt;!&lt;div class=&quot;code-wrapper&quot;&gt;)(&lt;pre.+?&lt;\/pre&gt;)/gim</span>s, <span class="hljs-function">(<span class="hljs-params">str, p1</span>) =&gt;</span> &#123;                <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/&lt;code[^&gt;]+?mermaid[^&gt;]+?&gt;/im</span>s.test(p1)) &#123;                    <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/(class=&quot;.*?)hljs(.*?&quot;)/gim</span>s, <span class="hljs-string">&#x27;$1$2&#x27;</span>);                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;div class=&quot;code-wrapper&quot;&gt;<span class="hljs-subst">$&#123;p1&#125;</span>&lt;/div&gt;`</span>;            &#125;);        &#125;        <span class="hljs-keyword">if</span> (hexo.config.highlight.line_number) &#123;            <span class="hljs-comment">// Mermaid block adaptation</span>            page.content = page.content.replace(<span class="hljs-regexp">/&lt;figure.+?&lt;td class=&quot;code&quot;&gt;.*?(&lt;pre.+?&lt;\/pre&gt;).+?&lt;\/figure&gt;/gim</span>s, <span class="hljs-function">(<span class="hljs-params">str, p1</span>) =&gt;</span> &#123;                <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/&lt;code[^&gt;]+?mermaid[^&gt;]+?&gt;/im</span>s.test(p1)) &#123;                    <span class="hljs-keyword">return</span> p1.replace(<span class="hljs-regexp">/(class=&quot;.*?)hljs(.*?&quot;)/gim</span>s, <span class="hljs-string">&#x27;$1$2&#x27;</span>).replace(<span class="hljs-regexp">/&lt;br&gt;/gim</span>s, <span class="hljs-string">&#x27;\n&#x27;</span>);                &#125;                <span class="hljs-keyword">return</span> str;            &#125;);        &#125;        <span class="hljs-keyword">return</span> page;    &#125;);</code></pre></div><p>好长的一段啊，但是大概是说禁用prismjs，然后根据yaml设置highlightjs的相关参数生成高亮配置参数。然后注入了一个渲染后的事件，传入渲染后的页面进行一些正则替换，主要是改变class，然后把替换好的代码包裹在一个div里边，注意，div的class为<strong>code-wrapper</strong>。</p><ol start="3"><li>实施替换</li></ol><p>看到教程中提到的某段话：</p><blockquote><p>添加了自动更换样式的脚本后，我们将需要替换到代码块的样式放入主题的css文件夹中，以便于浏览器能够正常渲染。在Yilia主题路径\source-src\css下，新建css文件，文件名为code-block.css。并复制以下代码blablabla……</p></blockquote><p>也就是说这个class就是我们后期渲染的关键。我们再找找Fluid是怎么渲染的呢？又是一段查找，.styl文件用于存放css样式，所以顺藤摸瓜找到了主题source目录下的css目录，一番折腾发现存放于该目录下_page下的rewrite.styl中。<strong>\fluid\source\css_pages_base</strong>。</p><p>根据关键字code-wrapper我们找到了定义的样式：</p><div class="hljs code-wrapper"><pre><code class="hljs css">&amp; &gt; <span class="hljs-selector-class">.code-wrapper</span>  <span class="hljs-attribute">position</span> relative  <span class="hljs-attribute">border-radius</span> <span class="hljs-number">3px</span></code></pre></div><p>这么简单嘛？那么我们就注释掉这段开始自定义样式咯，参照教程在新建在css目录下新建_custom目录，创建macpanel.styl。并在main.styl中引入。</p><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.code-wrapper</span>&#123;  <span class="hljs-attribute">position</span>: relative;  <span class="hljs-attribute">overflow</span>: hidden;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> <span class="hljs-number">0px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>);  <span class="hljs-attribute">margin</span>: <span class="hljs-number">30px</span> <span class="hljs-number">0</span>;  ::-webkit-scrollbar &#123;    height: <span class="hljs-number">10px</span>;  &#125;  ::-webkit-scrollbar-track &#123;    -webkit-box-shadow: inset <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">6px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.3</span>);    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;  &#125;  ::-webkit-scrollbar-thumb &#123;    border-radius: <span class="hljs-number">10px</span>;    -webkit-<span class="hljs-attribute">box-shadow</span>: inset <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">6px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);  &#125;  &amp;<span class="hljs-selector-pseudo">::before</span> &#123;    <span class="hljs-attribute">color</span>: white;    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">attr</span>(data-rel);    <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">30px</span>;    <span class="hljs-attribute">background</span>: <span class="hljs-number">#21252b</span>;    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Source Sans Pro&#x27;</span>, sans-serif;    <span class="hljs-attribute">font-weight</span>: bold;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span> <span class="hljs-number">80px</span>;    <span class="hljs-attribute">text-indent</span>: <span class="hljs-number">15px</span>;    <span class="hljs-attribute">float</span>: left;  &#125;  &amp;<span class="hljs-selector-pseudo">::after</span> &#123;    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27; &#x27;</span>;    <span class="hljs-attribute">position</span>: absolute;    -webkit-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">background</span>: <span class="hljs-number">#fc625d</span>;    <span class="hljs-attribute">width</span>: <span class="hljs-number">12px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">12px</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">left</span>: <span class="hljs-number">20px</span>;    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">13px</span>;    -webkit-<span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0px</span> <span class="hljs-number">#fdbc40</span>, <span class="hljs-number">40px</span> <span class="hljs-number">0px</span> <span class="hljs-number">#35cd4b</span>;    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0px</span> <span class="hljs-number">#fdbc40</span>, <span class="hljs-number">40px</span> <span class="hljs-number">0px</span> <span class="hljs-number">#35cd4b</span>;    <span class="hljs-attribute">z-index</span>: <span class="hljs-number">3</span>;  &#125;&#125;<span class="hljs-selector-class">.code-wrapper</span> &gt; pre &#123;<span class="hljs-attribute">margin-bottom</span> <span class="hljs-number">0</span>&#125;</code></pre></div><p>可能我还动了一些地方的css样式，但是大概都是调位置之类的<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="你真的理解浏览器盒模型吗">[2]</span></a></sup>，掌握沙盒模型然后调节rewrite和自定义的macpanel两个样式文件就可以了。效果就是你们看到的这样啦~</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>不折腾不痛快，所以需要一颗爱折腾的心……</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="http://oltremare.cc/2019092030716/">私人订制 为Yilia主题代码块添加Mac Panel效果</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://github.com/FrankKai/FrankKai.github.io/issues/38">你真的理解浏览器盒模型吗</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>折腾笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Fluid</tag>
      
      <tag>美化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基于FFMPEG自动截图上传至imgbox（四）</title>
    <link href="/2021/ckmf3rc7n000f6oag2b2g8tvx/"/>
    <url>/2021/ckmf3rc7n000f6oag2b2g8tvx/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>话接上回，我们已经实现了从视频到截图到bbcode的过程，但是还是有一个细节，很多网站短mediainfo没法弄，那么希望能够顺带也获取一下。</p><h3 id="核心代码及思想"><a href="#核心代码及思想" class="headerlink" title="核心代码及思想"></a>核心代码及思想</h3><hr><p>这次使用到的就是mediainfo了，这个在linux可以用 apt install mediainfo 安装，windows下可以下载一个cli版添加到环境变量。</p><p>教程：<a href="https://fossies.org/linux/MediaInfo_CLI/MediaInfo/Contrib/CLI_Help.doc">https://fossies.org/linux/MediaInfo_CLI/MediaInfo/Contrib/CLI_Help.doc</a></p><p>上面放了一个doc文档，可以自定义怎么输出剪短的mediainfo，但是我们现在就只需要长的就好了。话不多说，上代码：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_mediainfo</span>(<span class="hljs-params">file</span>) -&gt; str:</span>    process = subprocess.Popen([<span class="hljs-string">&quot;mediainfo&quot;</span>, file], stdout=subprocess.PIPE)    output, error = process.communicate()    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> error <span class="hljs-keyword">and</span> output != <span class="hljs-string">b&quot;\n&quot;</span>:        output = output.decode()  <span class="hljs-comment"># bytes -&gt; string</span>        output = re.sub(re.escape(file), os.path.basename(file), output)  <span class="hljs-comment"># Hide file path</span>        <span class="hljs-keyword">return</span> output    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span></code></pre></div><p>简而言之就是通过调用mediainfo命令获取到了想要的信息并且只保留视频文件名。</p><p>接下来就剩最后一个问题了，怎么快速获取到视频的存储路径呢？这里仅仅适合于qbittorrent，其他客户端应该也有类似的，先不探讨了。这里登场的模块叫做<a href="https://pypi.org/project/qbittorrent-api/">qbittorrent-api</a>，用于调用qbittorrent的web api达到一些想要的结果。话不多说，上代码：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> qbittorrentapi<span class="hljs-keyword">import</span> osqb_host = <span class="hljs-string">&quot;http://localhost:2021&quot;</span> <span class="hljs-comment"># 这里基本上部署在本地才可以截图所以就直接用localhost了,假设端口是2021</span>qb_name = <span class="hljs-string">&quot;admin&quot;</span>qb_pwd = <span class="hljs-string">&quot;123456&quot;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_save_path_from_hash</span>(<span class="hljs-params">hash_value</span>):</span>    <span class="hljs-comment"># 首先登陆qbittorrent之前需要开启webui，然后通过host, port(可选), name, password进行登录</span>    qb = qbittorrentapi.Client(host=qbt_address, port=qbt_port, username=qbt_user, password=qbt_password)    <span class="hljs-keyword">try</span>:    qb.auth_log_in()        torrents = qb.torrents_info(hashes=hash_value) <span class="hljs-comment"># 基本上有1个或者没有，返回种子列表</span>        torrent_name = torrents[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;name&#x27;</span>]        save_path = torrents[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;save_path&#x27;</span>] <span class="hljs-comment"># 获取到save_path和name基本上就可以得到视频或者视频文件的目录了</span>        path = os.path.join(save_path, torrent_name) <span class="hljs-comment"># 对path进行扫描获取到视频文件路径即可</span>        ...    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exc:        print(exc)</code></pre></div><p>qbittorrentapi还有很多其他的命令，这里只是用到了查询，还可以增删改，此处应有掌声。</p><p>到了这一步，其实已经算完结了。整合所有的代码就可以完成从hash到视频mediainfo到截图到上传。怎么样，应该是学会了吧？不会也不要紧，直接上链接。</p><p><code>https://github.com/tomorrow505/qbittorrent433/blob/main/get_mediaifno_picture.py</code></p><p>如果你想在盒子上部署，也可以用下面的命令一键部署：</p><p><code>wget https://raw.githubusercontent.com/tomorrow505/qbittorrent433/main/get_mediaifno_picture.sh -O get_mediaifno_picture.sh &amp;&amp; /bin/bash get_mediaifno_picture.sh</code></p><p>运行命令以后就可以用 up hash_of_torrent来进行传图了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>到了这一步，其实传图命令已经差不多了，Windows、linux下都可以愉快的截图上传了。</p><p>那么这一系列的教程就到此结束了，谢谢！！</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Python</tag>
      
      <tag>图床</tag>
      
      <tag>qbittorrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基于FFMPEG自动截图上传至imgbox（三）</title>
    <link href="/2021/ckmf3rc7l000a6oaghxm57hgy/"/>
    <url>/2021/ckmf3rc7l000a6oaghxm57hgy/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>话接上回，我们能够通过传递过来的视频文件路径截图图片存放到指定路径，并且返回了一个列表，那么我们怎么上传到指定图床？</p><h3 id="核心代码及思想"><a href="#核心代码及思想" class="headerlink" title="核心代码及思想"></a>核心代码及思想</h3><hr><p>我们在这个环节用到了一个imgbox的相关模块——<a href="https://pypi.org/project/pyimgbox/">pyimgbox</a>。使用到了协程相关知识，类似于老王泡茶那个故事话不多说，上代码：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<span class="hljs-keyword">import</span> pyimgbox<span class="hljs-comment"># 将之前获取到的图片的路径列表传入</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">up_imgbox</span>(<span class="hljs-params">filepaths, gallery_name</span>):</span>    result = [] <span class="hljs-comment"># 用于存放图片上传网址的bbcode列表</span>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> pyimgbox.Gallery(title=gallery_name) <span class="hljs-keyword">as</span> gallery: <span class="hljs-comment"># 该命令会创建一个名为gallery_name的相册</span>        gallery.thumb_width = <span class="hljs-number">350</span> <span class="hljs-comment"># 有的外站需要缩略图为350像素宽</span>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> submission <span class="hljs-keyword">in</span> gallery.add(filepaths): <span class="hljs-comment"># 开始添加任务，异步开始</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> submission[<span class="hljs-string">&#x27;success&#x27;</span>]: <span class="hljs-comment"># 失败的话打印任务失败原因</span>                print(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;submission[<span class="hljs-string">&#x27;filename&#x27;</span>]&#125;</span>: <span class="hljs-subst">&#123;submission[<span class="hljs-string">&#x27;error&#x27;</span>]&#125;</span>&quot;</span>)            <span class="hljs-keyword">else</span>:                print(submission)                result.append(<span class="hljs-string">&#x27;[url=%s][img]%s[/img][/url]&#x27;</span> % (submission[<span class="hljs-string">&#x27;web_url&#x27;</span>], submission[<span class="hljs-string">&#x27;thumbnail_url&#x27;</span>]))    <span class="hljs-keyword">return</span> result<span class="hljs-comment"># 上述函数的调用，标准范式</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_up_imgbox</span>(<span class="hljs-params">img_locs: <span class="hljs-built_in">list</span>=<span class="hljs-literal">None</span>, gallery_name: <span class="hljs-built_in">str</span>=<span class="hljs-literal">None</span></span>):</span>    loop = asyncio.get_event_loop()     task = loop.create_task(up_imgbox(img_locs, gallery_name))    loop.run_until_complete(task)    <span class="hljs-keyword">return</span> task.result()</code></pre></div><p>异步IO采用消息循环的模式，重复读取消息—处理消息的过程，也就是说异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程。</p><ul><li><p>event_loop 事件循环：程序开启一个无限的循环，程序员会把一些函数注册到事件循环上。当满足事件发生的时候，调用相应的协程函数。</p></li><li><p>coroutine 协程：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。</p></li><li><p>task 任务：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含任务的各种状态。</p></li><li><p>async/await 关键字： 用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口。</p></li></ul><p>再来看一个简单的例子：同步代码VS异步代码</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span>    time.sleep(<span class="hljs-number">1</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):        hello()        print(<span class="hljs-string">&#x27;Hello World:%s&#x27;</span> % time.time())  <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    run()Hello World:<span class="hljs-number">1536842494.2786784</span>Hello World:<span class="hljs-number">1536842495.2796268</span>Hello World:<span class="hljs-number">1536842496.2802596</span>Hello World:<span class="hljs-number">1536842497.2804587</span>Hello World:<span class="hljs-number">1536842498.2812462</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 定义异步函数</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>(<span class="hljs-params">i</span>):</span>    print(<span class="hljs-string">&#x27;Hello World %d :%s&#x27;</span> % (i, time.time()))    <span class="hljs-comment"># 必须使用await，不能使用yield from；如果是使用yield from ，需要采用@asyncio.coroutine相对应</span>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)    print(<span class="hljs-string">&#x27;Hello wow World %d :%s&#x27;</span> % (i, time.time()))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span>    tasks = []    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):        tasks.append(hello(i))    loop.run_until_complete(asyncio.wait(tasks))<span class="hljs-keyword">if</span> __name__ ==<span class="hljs-string">&#x27;__main__&#x27;</span>:    loop = asyncio.get_event_loop()    run()    loop.close()Hello World <span class="hljs-number">4</span> :<span class="hljs-number">1616070393.0068445</span>Hello World <span class="hljs-number">1</span> :<span class="hljs-number">1616070393.0068445</span>Hello World <span class="hljs-number">0</span> :<span class="hljs-number">1616070393.0068445</span>Hello World <span class="hljs-number">2</span> :<span class="hljs-number">1616070393.0068445</span>Hello World <span class="hljs-number">3</span> :<span class="hljs-number">1616070393.0068445</span>暂停约<span class="hljs-number">1</span>秒钟Hello wow World <span class="hljs-number">4</span> :<span class="hljs-number">1616070394.0171442</span>Hello wow World <span class="hljs-number">0</span> :<span class="hljs-number">1616070394.0171442</span>Hello wow World <span class="hljs-number">3</span> :<span class="hljs-number">1616070394.0171442</span>Hello wow World <span class="hljs-number">1</span> :<span class="hljs-number">1616070394.0171442</span>Hello wow World <span class="hljs-number">2</span> :<span class="hljs-number">1616070394.0171442</span></code></pre></div><p>大概说明一下：</p><ul><li>async def hello(): 定义async异步函数，中间可以添加await async.sleep(N) 来设定中断并执行下一个循环消息</li><li>tasks = [] 任务则是对协程进一步封装，其中包含任务的各种状态。即多个coroutine函数可以封装成一组Task然后并发执行</li><li>loop = asyncio.get_event_loop() #获取“事件循环”对象</li><li>loop.run_until_complete(asyncio.wait(tasks)) #通过事件循环，去调用协程函数</li><li>loop.close() 结束时间循环</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>pyimgbox已经封装好了其中的一些过程，所以我们可以通过传过来的视频文件路径获取到截图上传的bbcode了，但是其实还有一个mediainfo需要获取，这其实也不是什么难事。假设一个场景，我们从网页判断了一个种子转载的时候缺了截图或者mediainfo想要转到另一个网站，找视频文件地址不容易，或者盒子上也不好找。但是我们可以用qb获取到hash值来获得文件存储信息。预知后事，请听下回分解。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Python</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基于FFMPEG自动截图上传至imgbox（二）</title>
    <link href="/2021/ckmf3rc7l000b6oag1bymbixh/"/>
    <url>/2021/ckmf3rc7l000b6oag1bymbixh/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>话接上回，我么能够通过传递过来的视频文件路径获取视频长度和截图命令，那么如何使用python实现呢？</p><h3 id="核心代码及思想"><a href="#核心代码及思想" class="headerlink" title="核心代码及思想"></a>核心代码及思想</h3><hr><p>话不多说，上代码：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pymediainfo <span class="hljs-keyword">import</span> Mediainfo<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_video_info</span>(<span class="hljs-params">video_path</span>) -&gt; int:</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    :return: 视频长度，数字</span><span class="hljs-string">    &quot;&quot;&quot;</span>    media_info = MediaInfo.parse(video_path) <span class="hljs-comment"># 解析视频</span>    data = media_info.to_json()    data = json.loads(data)[<span class="hljs-string">&#x27;tracks&#x27;</span>]        <span class="hljs-comment"># 获取视频各种信息</span>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> data:        <span class="hljs-keyword">if</span> key[<span class="hljs-string">&#x27;track_type&#x27;</span>] == <span class="hljs-string">&#x27;Video&#x27;</span>:     <span class="hljs-comment"># 视频的总帧数除以帧率得到长度</span>            video_duration = <span class="hljs-built_in">int</span>(key[<span class="hljs-string">&#x27;frame_count&#x27;</span>]) / (<span class="hljs-built_in">int</span>(key[<span class="hljs-string">&#x27;frame_rate&#x27;</span>].split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">0</span>]))            <span class="hljs-keyword">return</span> video_duration</code></pre></div><p>上述代码可以直接得到一个视频的总的长度，但是我们想要截取图片的时候需要字符串，类似hh:mm:ss这样的。然后我们想要的是好几张图片？我以三张为例，假设一条线段想要有三个中间节点，那么我们会怎么处理呢？四等分就会有三个时间点了对不对？</p><p>比如60分钟的电影，我们取15分钟时间间隔，15, 30, 45 三个时间节点刚刚好，一般电影开头和截图截不出来什么东西的。我们需要把时间总长度4等分然后取三个节点将其转换成字符串传入截图函数中即可。</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<span class="hljs-comment"># 总的过程，传入一个时间长度，获取截图时间节点进行截图存储保存路径</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_thumbnails</span>(<span class="hljs-params">video_duration</span>):</span>    number = <span class="hljs-number">3</span> <span class="hljs-comment"># 截图张数</span>    picture_list = [] <span class="hljs-comment"># 用于存储截图的保存路径</span>    seektime = <span class="hljs-number">0</span> <span class="hljs-comment"># 用于记录截图距离开头的时长，以秒计</span>        interval = <span class="hljs-built_in">int</span>(video_duration/(number+<span class="hljs-number">1</span>)) <span class="hljs-comment"># 计算时间间隔</span>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, number):        seektime += interval <span class="hljs-comment"># 计算时间节点</span>        img = get_frame_at(seektime, n) <span class="hljs-comment"># 截取对应时间节点的图片</span>        <span class="hljs-keyword">if</span> img:            picture_list.append(img)    <span class="hljs-keyword">return</span> picture_list<span class="hljs-comment"># 被调用的函数，调用ffmpeg获取某一个时间节点的截图</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_frame_at</span>(<span class="hljs-params">seektime, n=<span class="hljs-number">99</span></span>):</span>    timestring = get_time_string(seektime) <span class="hljs-comment"># 将int型转为hh:mm:ss类型用于截图</span>    file_name = os.path.basename(video_path)    tmp_path = os.path.join(base_path, <span class="hljs-string">&#x27;tmp&#x27;</span>) <span class="hljs-comment"># 截图存放于事先新建的tmp目录下</span>    img_path = os.path.join(tmp_path, <span class="hljs-string">&quot;&#123;filename&#125;-out-&#123;d&#125;.png&quot;</span>.<span class="hljs-built_in">format</span>(filename=file_name, d=n)) <span class="hljs-comment"># 截图名称及存放绝对路径</span>    command = <span class="hljs-string">&#x27;ffmpeg -ss &#123;timestring&#125; -y -i &quot;&#123;file&#125;&quot; &quot;-f&quot; &quot;image2&quot; &quot;-frames:v&quot;  &quot;1&quot; &quot;-c:v&quot; &quot;png&quot; &#x27;</span> \    <span class="hljs-string">&#x27;&quot;-loglevel&quot; &quot;8&quot; &quot;&#123;img_path&#125;&quot;&#x27;</span>.<span class="hljs-built_in">format</span>(timestring=timestring, file=self.abs_file_path,                                          img_path=img_path)    <span class="hljs-keyword">try</span>:        subprocess.call(command, shell=<span class="hljs-literal">True</span>)        <span class="hljs-keyword">return</span> img_path    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exc:        logger.info(<span class="hljs-string">&#x27;截图失败：%s&#x27;</span> % exc)        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><span class="hljs-comment"># 用于将int型转换为字符串的函数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_time_string</span>(<span class="hljs-params">seconds</span>) -&gt; str:</span>    hours = <span class="hljs-built_in">int</span>(seconds // <span class="hljs-number">3600</span>)    minutes = <span class="hljs-built_in">int</span>((seconds % <span class="hljs-number">3600</span>) // <span class="hljs-number">60</span>)    seconds = <span class="hljs-built_in">int</span>(seconds % <span class="hljs-number">60</span>)    timestring = <span class="hljs-built_in">str</span>(hours) + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-built_in">str</span>(minutes).rjust(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;0&#x27;</span>) + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-built_in">str</span>(seconds).rjust(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;0&#x27;</span>)    <span class="hljs-keyword">return</span> timestring</code></pre></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>是的，现在已经能够通过视频路径获取截图到指定目录了，但是怎么上传呢？国内外的图床很多都有着丰富的API，所以还需要使用一些模块来完成上传的工作。本例子使用imgbox作为目标图床。预知后事，请听下回分解。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Python</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基于FFMPEG自动截图上传至imgbox（一）</title>
    <link href="/2021/ckmf3rc7800016oag0x7k0s36/"/>
    <url>/2021/ckmf3rc7800016oag0x7k0s36/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>玩PT的大概都知道发布的时候要上传mediainfo和截图，无论内外站都支持的图床之一就是imgbox。而无论是盒子还是本地，mediainfo或者截图上传都是比较繁琐枯燥的一件事情。那么，基于此，工具就来了。</p><p>这是一个比较系统的工具了，会用到一系列基础知识，所以打算做成一个系列。</p><p>本篇文章为第一篇：如何自动截取视频截图？</p><h3 id="FFMPEG"><a href="#FFMPEG" class="headerlink" title="FFMPEG"></a>FFMPEG</h3><hr><ul><li><p><a href="https://www.ffmpeg.org/">FFMPEG</a>是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。</p></li><li><p>FFMPEG在windows下安装教程链接。<a href="https://blog.csdn.net/Fish_cyy/article/details/105797337">https://blog.csdn.net/Fish_cyy/article/details/105797337</a></p></li></ul><p>总之FFMPEG的功能十分强大，无论是windows还是linux都可以使用。而今天我们主要说明如何使用该工具进行截图。废话不多说，直接上代码。</p><div class="hljs code-wrapper"><pre><code class="hljs bash">ffmpeg -ss &#123;timestring&#125; -y -i <span class="hljs-string">&quot;&#123;file&#125;&quot;</span> <span class="hljs-string">&quot;-f&quot;</span> <span class="hljs-string">&quot;image2&quot;</span> <span class="hljs-string">&quot;-frames:v&quot;</span> <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-string">&quot;-c:v&quot;</span> <span class="hljs-string">&quot;png&quot;</span> <span class="hljs-string">&quot;-loglevel&quot;</span> <span class="hljs-string">&quot;8&quot;</span> <span class="hljs-string">&quot;&#123;img_path&#125;&quot;</span><span class="hljs-comment"># 参数说明</span><span class="hljs-comment"># -ss................指定视频文件中截图的时间，01:00：00表示从视频文件的第一个小时截图</span><span class="hljs-comment"># -y.................表示覆盖，如果存在同名文件直接覆盖</span><span class="hljs-comment"># -i.................指定输入文件，使用双引号避免文件路径存在空格</span><span class="hljs-comment"># -f.................指定输出格式，image2表示输出图片</span><span class="hljs-comment"># -frames............指定截取几帧，这里指定为1</span><span class="hljs-comment"># -c.................编码格式，指定输出为png</span><span class="hljs-comment"># -loglevel..........日志等级相关参数，这里设置为8</span><span class="hljs-comment"># 最后img_path代表输出文件路径，包含文件名。</span><span class="hljs-comment"># 更多细节可以直接调用&quot;ffmpeg -h&quot;进行学习。</span></code></pre></div><p>很显然的一个问题，ffmpeg需要指定截图时间，那么视频有多长，什么时候开始截取呢？我们需要知道这个视频的长度。mediainfo便是一个很好的工具，而且ffmpeg直接就封装了mediainfo，可以直接使用指令获取视频信息：</p><p><code>ffmpeg -i test.mkv</code></p><p><img src="/post/ffmpeg.png" alt="ffmpeg"></p><p>忽略中文乱码我们其实可以获取到视频得长度的。其实我们还有一个python模块可以干这件事。<a href="https://pymediainfo.readthedocs.io/en/stable/">pymediainfo</a>使用代码示范：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint<span class="hljs-keyword">from</span> pymediainfo <span class="hljs-keyword">import</span> MediaInfomedia_info = MediaInfo.parse(<span class="hljs-string">&quot;my_video_file.mp4&quot;</span>)<span class="hljs-keyword">for</span> track <span class="hljs-keyword">in</span> media_info.tracks:    <span class="hljs-keyword">if</span> track.track_type == <span class="hljs-string">&quot;Video&quot;</span>:        print(<span class="hljs-string">&quot;Bit rate: &#123;t.bit_rate&#125;, Frame rate: &#123;t.frame_rate&#125;, &quot;</span>              <span class="hljs-string">&quot;Format: &#123;t.format&#125;&quot;</span>.<span class="hljs-built_in">format</span>(t=track)        )        print(<span class="hljs-string">&quot;Duration (raw value):&quot;</span>, track.duration)        print(<span class="hljs-string">&quot;Duration (other values:&quot;</span>)        pprint(track.other_duration)    <span class="hljs-keyword">elif</span> track.track_type == <span class="hljs-string">&quot;Audio&quot;</span>:        print(<span class="hljs-string">&quot;Track data:&quot;</span>)        pprint(track.to_data())</code></pre></div><p>得到的结果如下：</p><div class="hljs code-wrapper"><pre><code class="hljs python">Bit rate: <span class="hljs-number">3117597</span>, Frame rate: <span class="hljs-number">23.976</span>, Format: AVCDuration (raw value): <span class="hljs-number">958</span>Duration (other values):[<span class="hljs-string">&#x27;958 ms&#x27;</span>, <span class="hljs-string">&#x27;958 ms&#x27;</span>, <span class="hljs-string">&#x27;958 ms&#x27;</span>, <span class="hljs-string">&#x27;00:00:00.958&#x27;</span>, <span class="hljs-string">&#x27;00:00:00;23&#x27;</span>, <span class="hljs-string">&#x27;00:00:00.958 (00:00:00;23)&#x27;</span>]Track data:&#123;<span class="hljs-string">&#x27;bit_rate&#x27;</span>: <span class="hljs-number">236392</span>, <span class="hljs-string">&#x27;bit_rate_mode&#x27;</span>: <span class="hljs-string">&#x27;VBR&#x27;</span>, <span class="hljs-string">&#x27;channel_layout&#x27;</span>: <span class="hljs-string">&#x27;L R&#x27;</span>, <span class="hljs-string">&#x27;channel_positions&#x27;</span>: <span class="hljs-string">&#x27;Front: L R&#x27;</span>, <span class="hljs-string">&#x27;channel_s&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;codec_id&#x27;</span>: <span class="hljs-string">&#x27;mp4a-40-2&#x27;</span>, <span class="hljs-string">&#x27;commercial_name&#x27;</span>: <span class="hljs-string">&#x27;AAC&#x27;</span>, <span class="hljs-string">&#x27;compression_mode&#x27;</span>: <span class="hljs-string">&#x27;Lossy&#x27;</span>, …&#125;</code></pre></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>我们现在知道了ffmpeg的截图命令，也知道了怎么获取一个视频文件的时长，可能形式需要转换一下。那么在已知视频文件路径的前提下，如何用python进行截图操作呢？预知后事，请听下回分解。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Python</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu或者Debian环境下编译qbittorrent4.3.3</title>
    <link href="/2021/ckmf3rc7m000d6oag1ycr0oww/"/>
    <url>/2021/ckmf3rc7m000d6oag1ycr0oww/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>本文为安装最新或指定版本qBittorrent4.3.3的教学 适用于Ubuntu 18或更新版本，Debian 10或更新版本。</p><h3 id="安装须知"><a href="#安装须知" class="headerlink" title="安装须知"></a>安装须知</h3><hr><p>libtorrent是qBittorrent必要的后端程序，本教程使用1.2.12。在此之前需要安装编译libtorrent环境。</p><p>此外还依赖一些其他的包，在尝试的时候遇到了一些坑，都记录了下来，然后最近初学shell编程，所以整理了一个一键安装脚本。</p><p>最后的最后，在盒子上进行调试的时候3o会在编译qb的时候出现一个linking错误，后边看有没有机会修复吧。</p><h3 id="废话不多说，上部分代码"><a href="#废话不多说，上部分代码" class="headerlink" title="废话不多说，上部分代码"></a>废话不多说，上部分代码</h3><hr><ul><li>准备安装环境</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">apt updateapt -y install build-essential pkg-config automake libtool git libgeoip-dev python3 python3-devapt -y install libboost-dev libboost-system-dev libboost-chrono-dev libboost-random-dev libssl-devapt -y install qtbase5-dev qttools5-dev-tools libqt5svg5-dev zlib1g-dev</code></pre></div><ul><li>编译boost</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">apt-get -y install mpi-default-dev　　<span class="hljs-comment">#安装mpi库</span>apt-get -y install libicu-dev　　　　　<span class="hljs-comment">#支持正则表达式的UNICODE字符集　</span>apt-get -y install libbz2-devwget https://dl.bintray.com/boostorg/release/1.75.0/<span class="hljs-built_in">source</span>/boost_1_75_0.tar.bz2tar -jxvf boost_1_75_0.tar.bz2<span class="hljs-built_in">cd</span> boost_1_75_0sh ./bootstrap.sh./b2./b2/install</code></pre></div><ul><li>编译libtorrent</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">apt -y install libssl-devapt -y install opensslwget https://github.com/arvidn/libtorrent/releases/download/v1.2.12/libtorrent-rasterbar-1.2.11.tar.gztar xf libtorrent-rasterbar-1.2.12.tar.gz<span class="hljs-built_in">cd</span> libtorrent-rasterbar-1.2.12./configure --disable-debug --enable-encryption --with-libgeoip=system CXXFLAGS=-std=c++14make -j$(nproc)make installldconfig</code></pre></div><ul><li>安装qbittorrent</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">apt-get -y install qt5-defaultapt-get -y install zlib1g-dev<span class="hljs-comment"># 将命令改名，可能是新版本的调用脚本命名不一样了</span>file1=<span class="hljs-string">&quot;/usr/bin/lrelease&quot;</span>file2=<span class="hljs-string">&quot;/bin/lrelease&quot;</span><span class="hljs-keyword">if</span> [ -f <span class="hljs-string">&quot;<span class="hljs-variable">$file1</span>&quot;</span> ]; <span class="hljs-keyword">then</span>  mv <span class="hljs-string">&quot;<span class="hljs-variable">$file1</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;file1&#125;</span>-qt5&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [ -f <span class="hljs-string">&quot;<span class="hljs-variable">$file2</span>&quot;</span> ]; <span class="hljs-keyword">then</span>  mv <span class="hljs-string">&quot;<span class="hljs-variable">$file2</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;file21&#125;</span>-qt5&quot;</span><span class="hljs-keyword">fi</span><span class="hljs-comment"># mv /bin/lrelease /bin/lrelease-qt5</span><span class="hljs-comment"># mv /usr/lib/qt5/bin/lrelease /usr/lib/qt5/bin/lrelease-qt5</span>wget https://github.com/qbittorrent/qBittorrent/archive/release-4.3.3.tar.gztar xf release-4.3.3.tar.gz<span class="hljs-built_in">cd</span> qBittorrent-release-4.3.3./configure --disable-gui --disable-debug CXXFLAGS=-std=c++14make -j$(nproc)make install<span class="hljs-comment"># 写入service文件</span>qbit_service=<span class="hljs-string">&quot;/etc/systemd/system/qbittorrent.service&quot;</span>touch <span class="hljs-variable">$qbit_service</span>cat&gt;<span class="hljs-variable">$qbit_service</span>&lt;&lt;<span class="hljs-string">EOF</span><span class="hljs-string">[Unit]</span><span class="hljs-string">Description=qBittorrent Daemon Service</span><span class="hljs-string">After=network.target</span><span class="hljs-string">[Service]</span><span class="hljs-string">LimitNOFILE=512000</span><span class="hljs-string">User=root</span><span class="hljs-string">ExecStart=/usr/local/bin/qbittorrent-nox</span><span class="hljs-string">ExecStop=/usr/bin/killall -w qbittorrent-nox</span><span class="hljs-string">[Install]</span><span class="hljs-string">WantedBy=multi-user.target</span><span class="hljs-string">EOF</span>systemctl <span class="hljs-built_in">enable</span> qbittorrent.service <span class="hljs-comment"># 设置开机自启动</span>qbittorrent-nox -y --webui-port=2021 <span class="hljs-comment"># 打开尝试然后ctrl+c退出。</span><span class="hljs-comment"># 默认端口是2021哦，用户名admin，密码adminadmin。</span></code></pre></div><ul><li>设置qbittorrent命令</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">qbit_command=<span class="hljs-string">&quot;/usr/bin/qbittorrent&quot;</span>touch <span class="hljs-variable">$qbit_command</span>cat&gt;<span class="hljs-variable">$qbit_command</span>&lt;&lt;<span class="hljs-string">EOF</span><span class="hljs-string">#!/bin/bash</span><span class="hljs-string">if [ \$1 == &quot;start&quot;]</span><span class="hljs-string">then</span><span class="hljs-string">  systemctl start qbittorrent.service #启动qBittorrent</span><span class="hljs-string">elif [ \$1 == &quot;stop&quot;]</span><span class="hljs-string">then</span><span class="hljs-string">  systemctl stop qbittorrent.service #关闭qBittorrent</span><span class="hljs-string">elif [ \$1 == &quot;restart&quot;]</span><span class="hljs-string">then</span><span class="hljs-string">  systemctl restart qbittorrent.service #重启qBittorrent</span><span class="hljs-string">fi</span><span class="hljs-string">EOF</span><span class="hljs-built_in">cd</span> /usr/bin &amp;&amp; chmod +x qbittorrent<span class="hljs-comment">#之后就可以使用命令qbittorrent start|stop|restart 分别代表开始，关闭，重启。</span></code></pre></div><h3 id="食用方法"><a href="#食用方法" class="headerlink" title="食用方法"></a>食用方法</h3><hr><p>因为我已经整理成了shell文件放到我的<a href="https://github.com/tomorrow505/qbittorrent433">GitHub</a>上了，感兴趣的可以去看看源代码。</p><p><code>wget https://raw.githubusercontent.com/tomorrow505/qbittorrent433/main/install.sh -O install.sh &amp;&gt;/dev/null &amp;&amp; /bin/bash install.sh</code></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[1]：<a href="https://npchk.info/ubuntu-debian-install-qbittorrent/">Ubuntu/Debian Linux編譯qBittorrent安裝指南</a></p>]]></content>
    
    
    <categories>
      
      <category>业余爱好</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PT</tag>
      
      <tag>shell</tag>
      
      <tag>Linux</tag>
      
      <tag>qbittorrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的PT之路</title>
    <link href="/2021/ckmf3rc7q000k6oag3wolcl8n/"/>
    <url>/2021/ckmf3rc7q000k6oag3wolcl8n/</url>
    
    <content type="html"><![CDATA[<p>写在6年之期的一些小的感悟。</p><h2 id="影之大，一个优盘放不下"><a href="#影之大，一个优盘放不下" class="headerlink" title="影之大，一个优盘放不下"></a>影之大，一个优盘放不下</h2><p>早些年时候，硬盘大多4G-8G存一些课件之类的东西，足够了。突然有一天同学过来串门，说给我看一部电影《被解放的姜戈》，果断拿优盘过去拷，结果竟然放不下~尴了个尬的，一问多大，高清8G以上……好在教育网互传还挺快。才知道PT这么一回事，他的电影都是在学校PT站内下载的。说这我也想注册一个，结果傻眼了，未开放注册~~同学也就是个普通会员，没有邀请啥的。所以就等，说是每年会开注两次。</p><p>直到15年3月13日，估计是有人跟我说了，我才进了我的第一个PT站，一看很新奇，但是视频确实都很大。看了眼规则啥的，还要分享率、保种什么的，七七八八看下来，心里直觉得麻烦~~许是当时课程比较紧，就弃置了。</p><p>4月份的时候下载了第一部电影《外星醉汉PK地球神》，很喜欢阿米尔-汗，他的《三傻大闹宝莱坞》看了不下五遍，每一次看都有新的感触。但是不知为何，站点又再次搁置了，应该是比较忙的吧。</p><h2 id="迟来的发布员和开心的时光"><a href="#迟来的发布员和开心的时光" class="headerlink" title="迟来的发布员和开心的时光"></a>迟来的发布员和开心的时光</h2><p>到10月份的时候，一些事情算是尘埃落定了，我把之前在油管上爬的一个教程传了上去，看到有人下载，心里十分开心。Sharing changes the world. 是站点的理念，真的很感激那些为站点付出的人，看了下论坛，他们一个个都很有激情，让人不禁加入进去，于是我下载的第二个种子就是怎么上传种子到站点。</p><p>慢慢地，我开始使用百度云离线，QQ旋风，迅雷等去公网搜寻种子，然后转载过来。并且个人喜欢篮球，看NBA，所以也下载了很多NBA录像传了上去，也学到了很多发布的知识，那真是一段开心的时光，纯粹的开心。久了就有大佬PM：你愿意做发布员吗？此时我已经为了玩PT买了一个2T的西数移动硬盘，也几乎不怎么关电脑。答案自然是：Yes。</p><p>进了发布组，里边的大佬还是挺多的，09年开站，一代代的传承有很多已经成为公网的活跃分子。通过论坛的学习以及跟他们的交流，也规范了自己的发种姿势，更加知道了PT站的广阔天地。为了更好的转载，于是开始走上了收割之路……北邮人、落樱、清影、葡萄、馒头、春天、听听歌、蒲公英、好大啊、我堡等等。要么是论坛申请，要么是大佬在发布群内发邀，总之每次过考核都跟升级一样，时不时去看看，总是害怕不小心挂了。（当时还进了外网HDT，本地是要吐了，还要每个季度下载15G，想来后来肯定是放弃了，死掉了。）</p><h2 id="沉寂的时光太过漫长，写个工具吧"><a href="#沉寂的时光太过漫长，写个工具吧" class="headerlink" title="沉寂的时光太过漫长，写个工具吧"></a>沉寂的时光太过漫长，写个工具吧</h2><p>16年，校园站点意外关闭，收割的站点总是少了点什么，缺少一种归属感，像飘在外面一样，之前的发布组成员也一个个离开了，新进来的很少，校园PT的青黄不接就像河水断流，日渐颓势。好在还有站点可以逛，只是时间太漫长……</p><p>也不是说关了就一直没有开，偶尔开俩月，又维护，域名也是换来换去，慢慢地，用户就少了很多。</p><p>直到后来开站，已经不再支持IPV4，也没有什么工作组员了，我成为了一个版主。没有什么荣耀加身的乐趣，干的还是发布的活。当时落樱出了一个转载美剧的机器人，我们也萌生了这样的观念，想要快速把别的站资源转发过来。先后有了三个版本的种鸡，一个是Lancesaber基于python和tr的版本，需要配置环境自动运行。一个是rach的shell版本，也是基于qb，但是需要linux。当时想着是所有发布员都要用，所以第三个版本就是我的基于python和ut的半自动转载，之所以称之为半自动，是需要输入源种链接进去的，RSS是后期加上的。后来在Matthew的建议下使用了qb. 打包编译成了windows版本。</p><p>蛰伏的时间也很快，测试发种-修复bug-添加新站点-测试发种修复bug……终于还是基本成型了，于是开启了疯狂转种模式，上了京东两块4T（后悔死了），因为发布员很少了，基本上就是几台种鸡在跑，下载的人也寥寥，可是归属感在那里，有人下就接着发。于是乎，成为了管理，干的还是发布的活。</p><h2 id="开启公网之旅-那个男人是贝壳啊"><a href="#开启公网之旅-那个男人是贝壳啊" class="headerlink" title="开启公网之旅-那个男人是贝壳啊"></a>开启公网之旅-那个男人是贝壳啊</h2><p>转眼已经到了18年底。应该是这个时间节点吧，之前沉寂的时候也进了一些站点哇，南北洋、天空、朋友、家园。至今盛传八大只剩岛了，后来进站点都是走的论坛邀请区，因为孤岛所以没见官窑。</p><p>适逢春天关站后重开改域名，trcker也换了，用qb的都知道不能批量改，于是写了一个工具放在几个站点的论坛。后来突然一个贝壳图像的QQ加我说要把工具放到GitHub上，然后问种鸡能不能支持转发更多的站点。自己在校园站high了蛮久，或许是时候去外面看看了。</p><p>贝壳大佬邀请我进了猫，慢慢的进了备胎、铂金，直到8月岛开邀，终于集齐了。多数时间在校园网混迹的我，开始了种鸡适配之旅，这期间遇到了很多的问题，也有一些不愉快，大站点相对小站点的傲气是有资本积累的，无所谓对错，更多的时候就是不适合，所以我最终还是去往了相对较小较新的站点。由于种鸡适配，进入了猫站发布组，认识了很多大佬，轻松愉快，也知道了，那个男人叫贝壳大佬。</p><p>猫站的论坛可以学习到很多东西，也有很多nice的大佬。见识到了贝壳大佬、猫大、手大、宝大、86大、甘蔗大、空白大……都是一群极其厉害的人物，更加见识了，PT之路的无止境。</p><h2 id="外网之旅，你的脚本给我用一下吧"><a href="#外网之旅，你的脚本给我用一下吧" class="headerlink" title="外网之旅，你的脚本给我用一下吧"></a>外网之旅，你的脚本给我用一下吧</h2><p>时光很快到19年底，武汉的疫情牵动了整个国家的心，我们却迎来了最长的一个假期。在家里百无聊赖的时候，一个大佬说可以效仿别的站点搞一个美剧鸡，于是乎从猫站进了MTV，租了个小盒子开始把功能加到种鸡里边，由于自己没有太多看美剧的经验，没有甄别质量的想法，加之校园PT总是希望小体积的想法，写得不是很完善。另外当时需要拿盒子过岛的考核，时间一久，便没有精力再弄了。</p><p>期间进了吐鲁番、柠檬、杜比等等站点，也见证了柠檬的第一次发种大赛，宝大第一，手大拿着种鸡混了个第二，机智的雨小天大佬第三，后来才知道这个比赛还有钱拿，哈哈~~（国庆的时候果断参加了音乐大赛，真香。）</p><p>后来86大佬突然在群里问及一个js正则的问题，即使没有系统学过js，也帮忙解答了。后来有人在群里说旧的一键转载的脚本很多站点不能用了，本着助人为乐以及折腾无止境的精神，我找来了当时的脚本，帮忙把问题给解决了。宝大找到我说他还有一个高级版本的脚本，但是不太好用了。高级脚本牵扯到外站了，各个站点不一样，导致脚本整体脉络不是很清晰，想要厘清存在一些难度，与其补丁打满，不如开始重构。</p><p>于是乎，重构工作开始了，形如宝大、86大这类狠人站点可是真的多，一个接一个砸过来，我也就开始了外站。PHD，AVZ，HDT，RED，BHD，UHD，MTV，BLU，IPT，FL……同期还进了PTP，HDF，Xthor之类的。其中PTP是校园PT小伙伴给的，后来还在上面跟外国友人求到了KG。以及后来的后来跟daom求到的CG，86大佬求到的JPOP，以及最后的最后HDB，现在就等着一个BTN了。</p><p>脚本的编写还是有趣的，可以认识很多大佬，一起调试，期间因为大佬们的推荐，进了又一个潜力站点，柠檬，脚本也支持了众多国内小的站点，同时也在好几个发布组兼职。因为转载的还是那群人，就我自己而言，猫站是我的公网落脚站，柠檬是好朋友都在的站。所以脚本基本上会在这两个站的工作人员群更新。额外的人找到我也是同样的答案，想要脚本，去群里拿吧~</p><h2 id="一些看法和感悟"><a href="#一些看法和感悟" class="headerlink" title="一些看法和感悟"></a>一些看法和感悟</h2><p>其实贴吧是个交流的好地方，但是因为网络上不知道谁是谁，扯皮也时有存在，但是我还是倾向于干两件事：写工具和发邀请，尴尬的是，一则虽然qbittorrent有着很好的api，可以做很多有意思的工具，之前写了几个放在贴吧，无奈关注的人并不多。另外由于自身佛系本性，极少去大站打工，倒是喜欢在潜力新站里边玩，所以大站邀请并不多。倒是由于特殊原因，靠着大佬帮忙，帮助两个Pter收齐了九大。</p><p>个人的进军路线总结为：校园教育站-&gt;公网站-&gt;外网站。其中教育站由于连接性好，玩的比较多，公网是以后会用的比较多，也是一手资源出现的地方，很多官组什么的，外网站由于中文资源比较少，但是很多时候是一个补充，没有最好的，适合自己就好。进工作组认识大佬是个不错的途径，前提是有足够的的时间。</p><p>个人的保种观念及外网推荐：其实保种很多时候是一个站点存在的根本，发的再多没有保种没法下，感谢IYUU的出现~外网中的HR就是为了让大家多保种，我是本地保种党，自己也有30T左右的硬盘，而由于保种玩的称心的外站有FileList，JPOP，PTP，xthor，HDF、蓝鸟等等。不玩游戏所以没有GGN。</p><p>个人进站路线推荐：个人从来没有在贴吧求过邀请。心想，一来专一是好事，二来本地设备是优势，三来结识大佬是胜势。一个站点做种几万天，发种几百上千，这种人一般去求药应该不难；本地晒设备，有诚心，虚心请教，入门后数据好看，求药应该不难；认识大佬，谈笑风生，求种不难。求药场所无非贴吧、官窑、私信。还有TG什么的就不说了，但是三者都需要花费时间精力，如果想要速成，捐赠吧。</p><p>最后的最后，希望大家能够玩得开心，没有收到站点不要气馁，时间久了都会有。更多的发邀是相互选择，在不认识的前提下强调数据无可厚非，我倒是希望给更多的新人一些机会，发了蛮多邀请，希望大家能够珍惜手里的站点，通过它们，数据好一点结识大佬的机会就多一点，然后进入更广阔的天地。</p>]]></content>
    
    
    <categories>
      
      <category>业余爱好</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>PT</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
